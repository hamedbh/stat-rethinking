---
title: "Conditional Manatees"
output: html_document
---

```{r setup}
library(rethinking)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
library(patchwork)
library(zeallot)
library(dagitty)
library(ggdag)
library(ggrepel)
library(magrittr)
library(corrr)
library(furrr)
library(tidyverse)
# set up the theme
theme_set(
  theme_light() + 
    theme(panel.grid = element_blank())
)
```

The chapter introduces the idea of interactions. 

## Building an interaction

RM introduces the dataset on terrain ruggedness and economic output. 

```{r}
data(rugged)
drugged <- rugged %>% 
  as_tibble() %>% 
  drop_na(rgdppc_2000) %>% 
  mutate(
    log_gdp_std = log(rgdppc_2000) / mean(log(rgdppc_2000)), 
    rugged_std = rugged / max(rugged), 
    cid = as.integer(cont_africa + 1L)
  )

drugged %>% 
  transmute(
    country, 
    gdp = log_gdp_std, 
    rugged = rugged_std, 
    continent = if_else(
      cont_africa == 1L, 
      "African nations", 
      "Non-African nations"
    )
  ) %>% 
  mutate(gdp = gdp / mean(gdp)) %>% 
  ggplot(aes(rugged, gdp, colour = continent)) + 
  geom_point() + 
  stat_smooth(
    colour = "grey30", 
    method = "lm", 
    formula = "y ~ x", 
    fullrange = TRUE
  ) + 
  geom_text_repel(
    aes(label = country), 
    colour = "black", 
    data = . %>% 
      filter(
        country %in% c("Lesotho", "Seychelles", "Tajikistan", "Switzerland")
      )
  ) + 
  scale_fill_manual(
    values = c("steelblue", "grey50"), 
    aesthetics = c("colour", "fill")
  ) + 
  facet_wrap(~ continent, scales = "free_y") + 
  labs(
    x = "ruggedness (standardized)", 
    y = "log GDP (as proportion of mean)"
  ) + 
  theme(
    legend.position = "none"
  )
```

The relationship is opposite within each group. RM suggests a DAG that may be consistent with this relationship: 

```{r}
dagify(
  G ~ R + C + U, 
  R ~ U, 
  coords = tibble(
    name = c("R", "G", "C", "U"), 
    x = c(1, 2, 3, 2), 
    y = c(1, 1, 1, 0)
  )
) %>% 
  ggdag() + 
  theme_dag()
```

So that GDP is some function of the ruggedness, R, and the continent, C. 

RM discounts the idea of splitting the data and fitting models separately. One reason is that some parameters (e.g. the variance) should not necessarily vary across continents. The argument seems to be against sleepwalking into this sort of thing: if the variance should be different in each continent, model that explicitly. 

He also points out that anything using information criteria will not allow for comparing models using all the data to approaches fitting two separate models for Africa and the rest. 

### Making a rugged model

Start by fitting one model to all of the data. First attempt at the model: 

$$
\begin{align}
\log(y_i) &\sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i     &=    \alpha + \beta(r_i - \bar{r}) \\
\alpha    &\sim \mathcal{N}(1, 1) \\
\beta     &\sim \mathcal{N}(0, 1) \\
\sigma    &\sim \text{Exponential}(1)
\end{align}
$$


```{r}
m8_1_bad <- quap(
  flist = alist(
    log_gdp_std ~ dnorm(mu, sigma), 
    mu <- a + (b * (rugged_std - 0.215)), 
    a ~ dnorm(1, 1), 
    b ~ dnorm(0, 1), 
    sigma ~ dexp(1)
  ), 
  data = drugged
)
```

Now do the prior predictive simulation to see if these priors give something reasonable. 

```{r}
rugged_seq <- seq(-0.1, 1.1, length.out = 30)
set.seed(7)
fig_8_3_1 <- link(
  m8_1_bad, 
  post = extract.prior(m8_1_bad), 
  data = tibble(rugged_std = rugged_seq)
) %>% 
  as_tibble(
    .name_repair = ~ str_c(rugged_seq)
  ) %>% 
  rowid_to_column() %>% 
  slice_sample(n = 50) %>% 
  pivot_longer(
    cols = -rowid, 
    names_to = "rugged_std", 
    names_transform = list(rugged_std = parse_number), 
    values_to = "log_gdp_std"
  ) %>% 
  ggplot(aes(rugged_std, log_gdp_std, group = rowid)) + 
  geom_line(alpha = 0.5, colour = "grey50") + 
  coord_cartesian(
    xlim = c(0, 1), 
    ylim = c(0.5, 1.5)
  ) + 
  geom_hline(yintercept = range(drugged$log_gdp_std), linetype = 2) + 
  labs(
    title = sprintf("a ~ dnorm(1, 1)\nb ~ dnorm(0, 1)"), 
    x = "ruggedness", 
    y = "log GDP (prop of mean)"
  ) + 
  theme(plot.title = element_text(hjust = 0.49))
fig_8_3_1
```

This prior is useless: far too many of these lines are simply implausible. 

We make the priors stricter, so our new model is: 

$$
\begin{align}
\log(y_i) &\sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i     &=    \alpha + \beta(r_i - \bar{r}) \\
\alpha    &\sim \mathcal{N}(1, 0.1) \\
\beta     &\sim \mathcal{N}(0, 0.3) \\
\sigma    &\sim \text{Exponential}(1)
\end{align}
$$

Now refit the model and recreate the prior plot. 

```{r}
m8_1 <- quap(
  flist = alist(
    log_gdp_std ~ dnorm(mu, sigma), 
    mu <- a + (b * (rugged_std - 0.215)), 
    a ~ dnorm(1, 0.1), 
    b ~ dnorm(0, 0.3), 
    sigma ~ dexp(1)
  ), 
  data = drugged
)
```

```{r}
set.seed(7)
fig_8_3_2 <- link(
  m8_1, 
  post = extract.prior(m8_1), 
  data = tibble(rugged_std = rugged_seq)
) %>% 
  as_tibble(
    .name_repair = ~ str_c(rugged_seq)
  ) %>% 
  rowid_to_column() %>% 
  slice_sample(n = 50) %>% 
  pivot_longer(
    cols = -rowid, 
    names_to = "rugged_std", 
    names_transform = list(rugged_std = parse_number), 
    values_to = "log_gdp_std"
  ) %>% 
  ggplot(aes(rugged_std, log_gdp_std, group = rowid)) + 
  geom_line(alpha = 0.5, colour = "grey50") + 
  coord_cartesian(
    xlim = c(0, 1), 
    ylim = c(0.5, 1.5)
  ) + 
  geom_hline(yintercept = range(drugged$log_gdp_std), linetype = 2) + 
  labs(
    title = sprintf("a ~ dnorm(1, 0.1)\nb ~ dnorm(0, 0.3)"), 
    x = "ruggedness", 
    y = "log GDP (prop of mean)"
  ) + 
  theme(plot.title = element_text(hjust = 0.49))
fig_8_3_1 + fig_8_3_2
```

There are still some improbably strong relationships in that prior, but it's much more concentrated around values that could reasonably occur. 

```{r}
precis(m8_1)
```

The model fails to detect any relationship between ruggedness and GDP. 

### Adding an indicator variable isn't enough

The approach we used earlier with indicator variables won't work now. Why? Because that will only estimate different intercepts for each group (i.e. Africa and not-Africa). We can see from the earlier plot though that there are different _slopes_ in each group as well. So the model needs to account for this. 

RM then illustrates why it isn't enough to just estimate separate intercepts for each group, which I'll skip as the lesson seems clear. I'll fit the model though as we use it later for comparison. 

```{r}
m8_2 <- quap(
  flist = alist(
    log_gdp_std ~ dnorm(mu, sigma), 
    mu <- a[cid] + (b * (rugged_std - 0.215)), 
    a[cid] ~ dnorm(1, 0.1), 
    b ~ dnorm(0, 0.3), 
    sigma ~ dexp(1)
  ), 
  data = drugged
)
```


### Adding an interaction does work

Now we build the better model with varying intercepts and slopes. The linear model part is: 

$$
\mu_i = \alpha_{\text{CID}[i]} + \beta_{\text{CID}[i]}(r_i - \bar{r})
$$

Here ${\text{CID}[i]}$ is the indicator for continent. RM notes that this is better than the conventional approach to specifying an interaction like this, which would be: 

$$
\mu_i = \alpha_{\text{CID}[i]} + (\beta + \gamma A_i)(r_i - \bar{r})
$$

This would require us to set a prior on $\gamma$ (which is hard, since it doesn't have an obvious interpretation), and would repeat the issue mentioned above of more variability in Africa than elsewhere. 

Now fit the model. 

```{r}
m8_3 <- quap(
  flist = alist(
    log_gdp_std ~ dnorm(mu, sigma), 
    mu <- a[cid] + (b[cid] * (rugged_std - 0.215)), 
    a[cid] ~ dnorm(1, 0.1), 
    b[cid] ~ dnorm(0, 0.3), 
    sigma ~ dexp(1)
  ), 
  data = drugged
)
```

```{r}
precis(m8_3, depth = 2)
```

Now we get different slopes for each group: negative for non-African countries and positive for Africa (group 1 and 2 respectively). We also get estimates of the intercepts (i.e. the mean) that make sense: African countries on average have c. 90% of average GDP. 

Now compare the models: 

```{r}
set.seed(1)
compare(m8_1, m8_2, m8_3, func = PSIS)
```

We get a warning about high values for $k$, which we can plot. 

```{r}
set.seed(1)
PSIS(m8_3, pointwise = TRUE) %>% 
  rowid_to_column() %>% 
  ggplot(aes(rowid, k)) + 
  geom_point(colour = "steelblue", alpha = .6) + 
  geom_hline(yintercept = 0.5, linetype = 2, alpha = 0.6) + 
  scale_y_continuous(breaks = c(0.5, 1)) + 
  labs(x = NULL) + 
  theme(
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank()
  )
```

### Plotting an interaction

In this case it's relatively easy as we have a binary variable in our interaction, so we can just make two plots side by side. 

```{r}
set.seed(1105)
mu8_3 <- map_dfr(
  1:2, 
  ~ link(
    m8_3, 
    data = tibble(
      cid = .x, 
      rugged_std = rugged_seq
    )
  ) %>% 
    as_tibble(.name_repair = ~ str_c(rugged_seq)) %>% 
    rowid_to_column("sample_id") %>% 
    pivot_longer(
      -sample_id, 
      names_to = "rugged_std", names_transform = list(rugged_std = parse_number)
    ) %>% 
    mutate(cid = .x)
)
mu8_3_summary <- mu8_3 %>%
  group_by(cid, rugged_std) %>% 
  summarise(
    tibble(
      tibble(
        name = c("mean", "lower", "upper"), 
        value = c(mean(value), PI(value, prob = 0.97))
      )
    ), 
    .groups = "drop"
  ) %>% 
  pivot_wider() %>% 
  mutate(
    cid = if_else(
      cid == 1L, 
      "Non-African nations", 
      "African nations"
    )
  )
mu8_3_summary %>% 
  ggplot(aes(x = rugged_std)) + 
  geom_line(aes(y = mean)) + 
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = cid), alpha = 0.4) + 
  geom_point(
    aes(y = log_gdp_std, colour = cid), 
    data = drugged %>% 
      mutate(
        cid = if_else(
          cid == 1L, 
          "Non-African nations", 
          "African nations"
        )
      )
  ) + 
  geom_text_repel(
    aes(y = log_gdp_std, label = country), 
    data = drugged %>% 
      mutate(
        cid = if_else(
          cid == 1L, 
          "Non-African nations", 
          "African nations"
        )
      ) %>% 
      filter(
        country %in% c(
          "Equatorial Guinea", 
          "South Africa", 
          "Seychelles", 
          "Swaziland", 
          "Lesotho", 
          "Rwanda", 
          "Burundi", 
          "Luxembourg", 
          "Switzerland", 
          "Greece", 
          "Lebanon", 
          "Nepal", 
          "Tajikistan", 
          "Yemen"
        )
      ), 
    size = 3
  ) + 
  scale_fill_manual(
    aesthetics = c("fill", "colour"), values = c("steelblue", "black")
  ) + 
  facet_wrap(~ cid, scales = "free_y") + 
  labs(
    x = "ruggedness (standardised)", 
    y = "log GDP (as proportion of mean)"
  ) + 
  theme(legend.position = "none")
```

## Symmetry of interactions

RM points out that our framing of the interaction can flip but the underlying maths stays the same. Either we are: 

- Estimating the association between ruggedness and GDP conditional on the country being in Africa; or 
- Estimating the association between being in Africa and GDP conditional on the ruggedness of the country. 

The model for $\mu_i$ is: 

$$
\begin{align}
\mu_i = \alpha_{\text{CID}[i]} + \beta_{\text{CID}[i]}(r - \bar{r})
\end{align}
$$

This implies (particularly through the notation) that the slope is conditional on the continent. Rewriting the expression makes it easier to see the alternative interpretation though. 

$$
\begin{align}
\mu_i = (2 - \text{CID}_i)(\alpha_1 + \beta_1(r - \bar{r})) + (\text{CID}_i - 1)(\alpha_2 + \beta_2(r - \bar{r}))
\end{align}
$$

Exactly one of the terms in the sum will be non-zero for each country, and we can 'flip' the contintent for any country and get a different estimate for $\mu$ based on its ruggedness. 

```{r}
set.seed(1105)
mu8_3_delta <- map(
  1:2, 
  ~ link(
    m8_3, 
    data = tibble(
      cid = .x, 
      rugged_std = rugged_seq
    )
  )
) %>% 
  reduce(~ .y - .x) %>% 
  as_tibble(.name_repair = ~ str_c(rugged_seq)) %>% 
  rowid_to_column("sample_id") %>% 
  pivot_longer(
    -sample_id, 
    names_to = "rugged_std", names_transform = list(rugged_std = parse_number)
  )

mu8_3_delta_summary <- mu8_3_delta %>%
  group_by(rugged_std) %>% 
  summarise(
    tibble(
      tibble(
        name = c("mean", "lower", "upper"), 
        value = c(mean(value), PI(value, prob = 0.97))
      )
    ), 
    .groups = "drop"
  ) %>% 
  pivot_wider()

mu8_3_delta_summary %>% 
  ggplot(aes(x = rugged_std)) + 
  geom_line(aes(y = mean)) + 
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.4) + 
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.7) + 
  geom_text(
    aes(x = x, y = y, label = label), 
    data = tibble(
      x = c(0, 0), 
      y = c(-0.05, 0.05), 
      label = c("Africa lower GDP", "Africa higher GDP")
    ), 
    size = 4
  ) + 
  labs(
    x = "ruggedness", 
    y = "expected difference log GDP"
  )
```

## Continuous interactions

The previous example was relatively easy to visualise, but this becomes much harder with continuous interactions. 

### A winter flower

```{r}
data(tulips)
dtulips <- tulips %>% 
  as_tibble() %>% 
  mutate(
    W = water - mean(water),
    S = shade - mean(shade), 
    B = scales::rescale(blooms)
  )
str(dtulips)
```

We predict blooms as a function of water and shade. However these variables are both continuous and we expect them to interact. 

### The models

Can set up two models: with and without the interaction. First the model without. 

$$
\begin{align}
B_i   &\sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i &=    \alpha + \beta_W(W_i - \bar{W}) + \beta_S(S_i - \bar{S})
\end{align}
$$

So each predictor has been mean-centred. We also scale $B$ by its maximum, to make the interpretation easier. (All done above to make this step easier.)

RM also goes through the priors, which I'll skip for time. 

```{r}
m8_4 <- quap(
  flist = alist(
    B ~ dnorm(mu, sigma), 
    mu <- a + (bW * W) + (bS * S), 
    a ~ dnorm(0.5, 0.25), 
    c(bW, bS) ~ dnorm(0, 0.25), 
    sigma ~ dexp(1)
  ), 
  data = dtulips
)
```

RM suggests simulating from the prior, so we can do that. 

```{r}
set.seed(930)
prior8_4 <- extract.prior(m8_4) %>% 
  as_tibble() %>% 
  rowid_to_column()

(
  prior8_4 %>% 
  slice_sample(n = 100) %>% 
  expand(
    nesting(rowid, a, bW), 
    W = seq(-1.5, 1.5, length.out = 50)
  ) %>% 
  mutate(B = a + (bW * W)) %>% 
  ggplot(aes(W, B, group = rowid)) + 
  geom_line(alpha = 0.3) + 
  geom_hline(yintercept = c(0, 1), linetype = 2, alpha = 0.8)
) + (
  prior8_4 %>% 
  slice_sample(n = 100) %>% 
  expand(
    nesting(rowid, a, bS), 
    S = seq(-1.5, 1.5, length.out = 50)
  ) %>% 
  mutate(B = a + (bS * S)) %>% 
  ggplot(aes(S, B, group = rowid)) + 
  geom_line(alpha = 0.3) + 
  geom_hline(yintercept = c(0, 1), linetype = 2, alpha = 0.8)
)
```

There are some improbable lines but most of them are within the range of reasonable values. 

Now we can build the model including the interaction. RM shows that the traditional presentation of an interaction term derives from replacing the coefficient for one of the predictors with a linear model, and then expanding it out. 

$$
\begin{align}
\mu_i         &= \alpha + \gamma_{W, i} W_i + \beta_S S_i \\
\gamma_{W, i} &= \beta_W + \beta_{WS} S_i \\
\mu_i         &= \alpha + (\beta_W + \beta_{WS} S_i) W_i + \beta_S S_i \\
              &= \alpha + \beta_W W_i + \beta_S S_i + \beta_{WS} W_i S_i
\end{align}
$$

The process is completely symmetrical, so we could have replaced $\beta_S$ with a linear model instead and got the same answer. If we did both at once we would just find that instead of $\beta_{WS}$ as the coefficient for the product we would get $\beta_{WS} + \beta_{SW}$, which we can relabel easily as $\beta_{WS}$. So all of these are mathematically equivalent. 

So the interaction model is: 

$$
\begin{align}
B_i   &\sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i &=    \alpha + \beta_W W_i + \beta_S S_i + \beta_{WS} W_i S_i
\end{align}
$$

```{r}
m8_5 <- quap(
  flist = alist(
    B ~ dnorm(mu, sigma), 
    mu <- a + (bW * W) + (bS * S) + (bWS * W * S), 
    a ~ dnorm(0.5, 0.25), 
    c(bW, bS, bWS) ~ dnorm(0, 0.25), 
    sigma ~ dexp(1)
  ), 
  data = dtulips
)

precis(m8_5)
```

### Plotting posterior predictions

RM suggests triptych plots: each shows the effect of one predictor on the outcome with the other predictor held constant. The three plots would have low, medium, and high values for the constant predictor. It's easier here because we have just three possible values for each predictor. 

```{r}
plot_tulips <- function(quap_fit) {
  mod_name <- deparse(match.call()[[2]])
  map_dfr(
    c(-1, 0, 1), 
    ~ link(quap_fit, data = tibble(S = .x, W = c(-1, 0, 1))) %>% 
      as_tibble(.name_repair = ~ str_c(c(-1, 0, 1))) %>% 
      slice_sample(n = 20) %>% 
      rowid_to_column("sample_id") %>% 
      pivot_longer(
        -sample_id, 
        names_to = "W", 
        names_transform = list(W = parse_number), 
        values_to = "B"
      ) %>% 
      mutate(S = .x)
  ) %>% 
    mutate(S = sprintf("%s post: shade = %s", mod_name, S)) %>% 
    ggplot(aes(W, B)) + 
    geom_point(
      data = dtulips %>% 
        mutate(S = sprintf("%s post: shade = %s", mod_name, S)), 
      colour = "steelblue"
    ) + 
    geom_line(aes(group = sample_id), alpha = 0.4) + 
    scale_y_continuous("blooms", breaks = c(0, 0.5, 1)) + 
    scale_x_continuous("water", breaks = c(0, 0.5, 1)) + 
    facet_wrap(~ S)
}
set.seed(1033)
plot_tulips(m8_4) /
  plot_tulips(m8_5)
```

### Plotting prior predictions

```{r}
plot_prior_tulips <- function(quap_fit) {
  mod_name <- deparse(match.call()[[2]])
  map_dfr(
    c(-1, 0, 1), 
    ~ link(
      quap_fit, 
      data = tibble(S = .x, W = c(-1, 0, 1)), 
      post = extract.prior(quap_fit)
    ) %>% 
      as_tibble(.name_repair = ~ str_c(c(-1, 0, 1))) %>% 
      slice_sample(n = 20) %>% 
      rowid_to_column("sample_id") %>% 
      pivot_longer(
        -sample_id, 
        names_to = "W", 
        names_transform = list(W = parse_number), 
        values_to = "B"
      ) %>% 
      mutate(S = .x)
  ) %>% 
    mutate(S = sprintf("%s prior: shade = %s", mod_name, S)) %>% 
    ggplot(aes(W, B)) + 
    geom_line(aes(group = sample_id), alpha = 0.4) + 
    geom_hline(yintercept = c(0, 1), linetype = 2, alpha = 0.8) + 
    scale_y_continuous("blooms", breaks = c(0, 0.5, 1)) + 
    scale_x_continuous("water", breaks = c(0, 0.5, 1), limits = c(-1, 1)) + 
    facet_wrap(~ S)
}
set.seed(1033)
plot_prior_tulips(m8_4) /
  plot_prior_tulips(m8_5)
```

## Summary

The embedded linear model thing was genuinely eye-opening. Also interesting that interactions are not specified in a DAG: the DAG shows only which variables affect another, but not how they may combine to do so. 
